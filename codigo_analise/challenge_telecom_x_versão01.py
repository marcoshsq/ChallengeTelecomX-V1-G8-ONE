# -*- coding: utf-8 -*-
"""Challenge_Telecom_X_VersÃ£o01.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T5CwX6JniHnCtVm-bu2BU0VcFyCt1OnX

# ğŸ“Š Projeto: AnÃ¡lise de EvasÃ£o de Clientes da Telecom X

Este projeto faz parte do Challenge Telecom X proposto pela trilha de Data Science do Oracle Next Education (ONE). O objetivo principal Ã© realizar uma anÃ¡lise exploratÃ³ria dos dados de clientes da Telecom X para entender os fatores relacionados ao churn (evasÃ£o de clientes), apoiando futuras estratÃ©gias de retenÃ§Ã£o.

---

## ğŸ“Œ Etapa 1: ExtraÃ§Ã£o dos Dados (E - Extract)

Nesta etapa, realizaremos a extraÃ§Ã£o dos dados no formato `.json`, disponÃ­veis por meio de uma URL pÃºblica no GitHub. A ideia Ã© simular a coleta de dados de uma API, mesmo que a fonte seja um arquivo estÃ¡tico.

### ğŸ§° ImportaÃ§Ã£o de Bibliotecas

As bibliotecas abaixo sÃ£o essenciais para a execuÃ§Ã£o do projeto:

- `pandas` e `numpy`: para manipulaÃ§Ã£o e anÃ¡lise dos dados;
- `matplotlib.pyplot` e `seaborn`: para criaÃ§Ã£o de grÃ¡ficos e visualizaÃ§Ãµes;
- `scipy.stats`: para anÃ¡lises estatÃ­sticas exploratÃ³rias;
- `warnings`: para ocultar avisos que nÃ£o afetam a execuÃ§Ã£o;
- `plt.style.use("ggplot")`: configura um estilo mais limpo e visualmente agradÃ¡vel para os grÃ¡ficos;
- `sns.set_palette("Set2")`: define uma paleta suave para os grÃ¡ficos do Seaborn.
"""

# ğŸ§° ImportaÃ§Ã£o de bibliotecas principais

# ManipulaÃ§Ã£o de dados
import pandas as pd
import numpy as np

# VisualizaÃ§Ã£o de dados
import matplotlib.pyplot as plt
import seaborn as sns

# EstatÃ­sticas e testes
from scipy import stats

# ConfiguraÃ§Ã£o de estilo para os grÃ¡ficos
plt.style.use("ggplot")
sns.set_palette("Set2")

# Ignorar avisos desnecessÃ¡rios
import warnings
warnings.filterwarnings('ignore')

# URL do arquivo JSON (emula um endpoint de API)
url = "https://raw.githubusercontent.com/alura-cursos/challenge2-data-science/refs/heads/main/TelecomX_Data.json"

# Carregando os dados
df = pd.read_json(url)

# Exibindo as primeiras linhas
df.head()

"""### ğŸ“‹ VisÃ£o Geral dos Dados

Vamos inspecionar a estrutura inicial dos dados, checar o tamanho do DataFrame, tipos de colunas e verificar se existem dados ausentes.


"""

# Formato do DataFrame
print("Formato do DataFrame:", df.shape)

# Tipos de dados
df.dtypes

# InformaÃ§Ãµes gerais
df.info()

# Amostragem aleatÃ³ria
df.sample(5)

"""## ğŸ”§ Etapa 2: TransformaÃ§Ã£o dos Dados (T - Transform)

Agora que os dados foram extraÃ­dos com sucesso, Ã© hora de entendÃª-los mais a fundo e preparÃ¡-los para as prÃ³ximas etapas da anÃ¡lise. Nesta etapa vamos:

- Compreender a estrutura das colunas e tipos de dados;
- Identificar e tratar inconsistÃªncias;
- Expandir colunas compostas (como dicionÃ¡rios aninhados);
- Criar novas variÃ¡veis Ãºteis, como o faturamento diÃ¡rio;
- (Opcional) Padronizar e transformar os dados para facilitar a anÃ¡lise futura.

âœ… Ao final desta etapa, teremos um dataset limpo, estruturado e pronto para anÃ¡lise exploratÃ³ria.

---

#### DicionÃ¡rio de dados

* `customerID`: nÃºmero de identificaÃ§Ã£o Ãºnico de cada cliente
* `Churn`: se o cliente deixou ou nÃ£o a empresa
* `gender`: gÃªnero (masculino e feminino)
* `SeniorCitizen`: informaÃ§Ã£o sobre um cliente ter ou nÃ£o idade igual ou maior que 65 anos
* `Partner`:  se o cliente possui ou nÃ£o um parceiro ou parceira
* `Dependents`: se o cliente possui ou nÃ£o dependentes
* `tenure`:  meses de contrato do cliente
* `PhoneService`: assinatura de serviÃ§o telefÃ´nico
* `MultipleLines`: assisnatura de mais de uma linha de telefone
* `InternetService`: assinatura de um provedor internet
* `OnlineSecurity`: assinatura adicional de seguranÃ§a online
* `OnlineBackup`: assinatura adicional de backup online
* `DeviceProtection`: assinatura adicional de proteÃ§Ã£o no dispositivo
* `TechSupport`: assinatura adicional de suporte tÃ©cnico, menos tempo de espera
* `StreamingTV`: assinatura de TV a cabo
* `StreamingMovies`: assinatura de streaming de filmes
* `Contract`: tipo de contrato
* `PaperlessBilling`: se o cliente prefere receber online a fatura
* `PaymentMethod`: forma de pagamento
* `Charges.Monthly`: total de todos os serviÃ§os do cliente por mÃªs
* `Charges.Total`: total gasto pelo cliente

### ğŸ§© 2.1 Conhecendo a Estrutura dos Dados

Algumas colunas do dataset nÃ£o estÃ£o planas, ou seja, contÃªm estruturas do tipo `dict` com vÃ¡rias sub-informaÃ§Ãµes. Vamos descompactar essas colunas e integrÃ¡-las ao DataFrame principal para facilitar a anÃ¡lise.

AlÃ©m disso, faremos uma anÃ¡lise exploratÃ³ria rÃ¡pida para:

- Verificar o tipo de cada coluna;
- Observar categorias disponÃ­veis em variÃ¡veis qualitativas;
- Consultar o dicionÃ¡rio de dados oficial, caso necessÃ¡rio.

---
"""

# ğŸ“‹ Verificando o tipo de dado de cada coluna
print("Tipos de dados por coluna:\n")
print(df.dtypes)

# ğŸ” Verificando amostras das colunas com dicionÃ¡rios
# Vamos ver o conteÃºdo da primeira linha de cada coluna aninhada

print("Exemplo da coluna 'customer':\n", df["customer"].iloc[0])
print("\nExemplo da coluna 'phone':\n", df["phone"].iloc[0])
print("\nExemplo da coluna 'internet':\n", df["internet"].iloc[0])
print("\nExemplo da coluna 'account':\n", df["account"].iloc[0])

"""### ğŸ§© ConclusÃµes: 2.1 Conhecendo a Estrutura dos Dados

Nesta etapa, exploramos a estrutura interna do dataset e identificamos colunas que precisam de transformaÃ§Ã£o futura.

- O dataset possui 7267 registros e 6 colunas.
- Das 6 colunas, 4 contÃªm dados estruturados como dicionÃ¡rios:
  - `customer`, `phone`, `internet`, `account`
- Essas colunas precisam ser "explodidas" futuramente para facilitar a anÃ¡lise.

No momento, apenas identificamos essa estrutura. As transformaÃ§Ãµes serÃ£o feitas na prÃ³xima etapa (2.3).

### ğŸ§¹ 2.2 Verificando InconsistÃªncias

Nesta etapa, procuramos:

- Valores nulos;
- Duplicidades;
- Categorias inconsistentes (ex: espaÃ§os em branco, letras maiÃºsculas e minÃºsculas misturadas);
- Tipos incorretos (ex: nÃºmeros como string, datas nÃ£o reconhecidas, etc.).

---
"""

# ğŸ” Verificando a quantidade de valores nulos por coluna
df.isnull().sum()

# ğŸ’¯ Porcentagem de valores nulos por coluna
(df.isnull().sum() / df.shape[0]) * 100

# ğŸ” Verificando se hÃ¡ IDs de cliente duplicados
df['customerID'].duplicated().sum()

# ğŸ” Verificando os valores Ãºnicos de 'Churn'
df['Churn'].unique()

# ğŸ“Š FrequÃªncia de valores de 'Churn'
df['Churn'].value_counts()

# ğŸ§ª Verificando se hÃ¡ campos com string vazia em todas as colunas de nÃ­vel superior
for col in df.columns:
    if df[col].dtype == 'object':
        count_empty = (df[col] == '').sum()
        if count_empty > 0:
            print(f"Coluna '{col}' possui {count_empty} valores vazios ('').")

"""### ğŸ”§ 2.3 Tratando as InconsistÃªncias

Uma vez identificados os problemas, vamos corrigi-los:

- Preencher ou excluir valores ausentes (caso necessÃ¡rio);
- Corrigir categorias (padronizando letras, removendo espaÃ§os);
- Explodir os dicionÃ¡rios em colunas separadas;
- Garantir coerÃªncia nos tipos de dados.

---
"""

# ğŸ§¹ Substituindo valores vazios por NaN em 'Churn'
df['Churn'] = df['Churn'].replace('', np.nan)

# ğŸ” Verificando novamente os valores Ãºnicos
df['Churn'].value_counts(dropna=False)

# ğŸ§± Separando as colunas que estÃ£o em formato de dicionÃ¡rio
df_customer = pd.json_normalize(df['customer'])
df_phone = pd.json_normalize(df['phone'])
df_internet = pd.json_normalize(df['internet'])
df_account = pd.json_normalize(df['account'])

# ğŸ”— Concatenando os dados transformados ao DataFrame original
df = pd.concat([
    df.drop(columns=['customer', 'phone', 'internet', 'account']),
    df_customer,
    df_phone,
    df_internet,
    df_account
], axis=1)

# ğŸ‘€ Visualizando as 5 primeiras linhas do novo DataFrame
df.head()

# ğŸ“ Verificando o novo shape
df.shape

"""### ğŸ’¡ 2.4 Criando a Coluna `Contas_Diarias`

Para ter uma visÃ£o mais granular sobre o faturamento dos clientes, criaremos a coluna `Contas_Diarias`, calculando o valor mÃ©dio diÃ¡rio com base na coluna `Charges.Monthly`:

```python
df["Contas_Diarias"] = df["Charges.Monthly"] / 30
"""

# ğŸ” Conferindo os tipos novamente
df.dtypes

# ğŸ” Convertendo Charges.Total para float (coercivo)
df['Charges.Total'] = pd.to_numeric(df['Charges.Total'], errors='coerce')

# ğŸ” Verificando se houve valores nÃ£o conversÃ­veis (viraram NaN)
df['Charges.Total'].isnull().sum()

# ğŸ” Conferindo os tipos novamente
df.dtypes

# ğŸ’¡ Criando a coluna Contas_Diarias
df['Contas_Diarias'] = df['Charges.Monthly'] / 30

# ğŸ‘€ Visualizando as 5 primeiras linhas
df[['Charges.Monthly', 'Contas_Diarias']].head()

"""### ğŸ”„ 2.5 PadronizaÃ§Ã£o e TransformaÃ§Ã£o de Dados (Opcional)
Caso necessÃ¡rio, aplicaremos:

- TraduÃ§Ã£o ou renomeaÃ§Ã£o de colunas;
- ConversÃ£o de variÃ¡veis categÃ³ricas para numÃ©ricas (por exemplo, "Yes"/"No" â†’ 1/0);
- PadronizaÃ§Ã£o de nomenclaturas (ex: substituiÃ§Ã£o de espaÃ§os por underscore, tudo em minÃºsculas).

Esta etapa melhora a clareza do dataset e facilita a aplicaÃ§Ã£o de modelos preditivos posteriormente.
"""

# ğŸ” Verificando colunas com valores "Yes"/"No"
for col in df.columns:
    if df[col].dtype == 'object':
        uniques = df[col].dropna().unique()
        if set(uniques).issubset({'Yes', 'No'}):
            print(f"Coluna binÃ¡ria detectada: {col}")

# ğŸ” Convertendo colunas binÃ¡rias para 0 e 1
cols_binarias = ['Churn', 'Partner', 'Dependents', 'PhoneService', 'PaperlessBilling']

for col in cols_binarias:
    df[col] = df[col].map({'Yes': 1, 'No': 0})

# âœ… Verificando os valores Ãºnicos apÃ³s conversÃ£o
for col in cols_binarias:
    print(f"{col}: {df[col].unique()}")

# ğŸ”¡ Padronizando texto: minÃºsculas + remoÃ§Ã£o de espaÃ§os extras
for col in df.select_dtypes(include='object').columns:
    if col != 'customerID':
        df[col] = df[col].str.strip().str.lower()

df[['gender', 'MultipleLines', 'InternetService']].sample(5)

# ğŸ·ï¸ Renomeando colunas para o padrÃ£o snake_case
df = df.rename(columns={
    'customerID': 'customer_id',
    'SeniorCitizen': 'is_senior',
    'Charges.Monthly': 'charges_monthly',
    'Charges.Total': 'charges_total',
    'Contas_Diarias': 'daily_charges'
})

df.rename(columns={
    'Contract': 'contract',
    'PaperlessBilling': 'paperless_billing',
    'PaymentMethod': 'payment_method',
    'InternetService': 'internet_service',
    'OnlineSecurity': 'online_security',
    'OnlineBackup': 'online_backup',
    'DeviceProtection': 'device_protection',
    'TechSupport': 'tech_support',
    'StreamingTV': 'streaming_tv',
    'StreamingMovies': 'streaming_movies',
    'MultipleLines': 'multiple_lines',
    'PhoneService': 'phone_service'
}, inplace=True)

df.columns

"""# ğŸ” Etapa 3: AnÃ¡lise ExploratÃ³ria de Dados ((L - Load & Analysis))

Nesta etapa, vamos explorar o comportamento dos clientes e identificar padrÃµes associados Ã  evasÃ£o (churn). A anÃ¡lise serÃ¡ dividida em blocos temÃ¡ticos, acompanhada de perguntas orientadoras.

---

## ğŸ“Š 3.1 AnÃ¡lise Descritiva Geral

Vamos comeÃ§ar com uma visÃ£o geral do dataset, observando medidas como mÃ©dia, mediana, desvio padrÃ£o e valores mÃ­nimos/mÃ¡ximos.

**Perguntas que queremos responder:**
- Qual Ã© o gasto mÃ©dio mensal dos clientes?
- Qual a mediana do tempo de permanÃªncia (tenure)?
- HÃ¡ muitos outliers nas variÃ¡veis de valor?

---
"""

# ğŸ“Š EstatÃ­sticas descritivas das variÃ¡veis numÃ©ricas
df.describe().T

# ğŸ” Selecionando colunas especÃ­ficas
df[['tenure', 'charges_monthly', 'charges_total', 'daily_charges']].describe().T

# ğŸ§  Insights automatizados usando f-strings
media_charges = df['charges_monthly'].mean()
mediana_tenure = df['tenure'].median()
churn_rate = df['Churn'].mean() * 100
media_total = df['charges_total'].mean()
max_total = df['charges_total'].max()
senior_pct = df['is_senior'].mean() * 100
partner_pct = df['Partner'].mean() * 100
dependents_pct = df['Dependents'].mean() * 100
phone_pct = df['PhoneService'].mean() * 100

# Principais ObservaÃ§Ãµes da AnÃ¡lise Descritiva
print(f"""
ğŸ“Š Principais ObservaÃ§Ãµes da AnÃ¡lise Descritiva:

- Churn: Aproximadamente {churn_rate:.1f}% dos clientes cancelaram â€” um Ã­ndice significativo.
- Tenure: A mediana Ã© de {mediana_tenure:.0f} meses â€” metade dos clientes permanece por mais de 2 anos.
- Charges Monthly: Gasto mensal mÃ©dio de R$ {media_charges:.2f}.
- Charges Total: MÃ©dia de R$ {media_total:.2f} com um mÃ¡ximo de R$ {max_total:.2f}.
- SeniorCitizen: Apenas {senior_pct:.1f}% dos clientes tÃªm 65 anos ou mais.
- Partner: {partner_pct:.1f}% possuem parceiro(a).
- Dependents: {dependents_pct:.1f}% possuem dependentes.
- PhoneService: {phone_pct:.1f}% dos clientes possuem serviÃ§o telefÃ´nico.
""")

from IPython.display import Markdown

Markdown("""
### ğŸ“Š Principais ObservaÃ§Ãµes da AnÃ¡lise Descritiva

- **Churn**: Cerca de **26,5%** dos clientes cancelaram â€” um Ã­ndice significativo.
- **Tenure**: A mediana Ã© de **29 meses** â€” metade dos clientes permanece por mais de 2 anos.
- **Charges Monthly**: Gasto mensal mÃ©dio de **R$ 64,72**, com desvio padrÃ£o de **R$ 30** â€” hÃ¡ bastante variaÃ§Ã£o.
- **Charges Total**: MÃ©dia de **R$ 2.280** com mÃ¡ximo de **R$ 8.684** â€” possÃ­vel presenÃ§a de outliers.
- **Daily Charges**: Calculado com base no gasto mensal, apresenta distribuiÃ§Ã£o coerente.
- **SeniorCitizen**: Apenas **16%** dos clientes tÃªm 65 anos ou mais.
- **Partner e Dependents**: 48% possuem parceiro(a) e apenas 30% possuem dependentes.
- **PhoneService**: A maioria dos clientes (**90%**) tem serviÃ§o telefÃ´nico.
""")

"""## ğŸ“ˆ 3.2 DistribuiÃ§Ã£o Geral da EvasÃ£o

Nesta etapa, analisamos como a variÃ¡vel `churn` estÃ¡ distribuÃ­da entre os clientes.

**Perguntas que queremos responder:**
- Qual Ã© a proporÃ§Ã£o de clientes que cancelaram versus os que permaneceram?
- O churn Ã© um problema significativo na base de clientes?

---
"""

# ğŸ“Š DistribuiÃ§Ã£o da EvasÃ£o com grÃ¡fico de barras
plt.figure(figsize=(12, 6))
sns.countplot(x='Churn', data=df, palette='Set2')
plt.title('DistribuiÃ§Ã£o Geral da EvasÃ£o de Clientes')
plt.ylabel('Quantidade de Clientes')
plt.xticks([0, 1], ['Permaneceu', 'Cancelou'])
plt.grid(axis='y', linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

# ğŸ“‰ ProporÃ§Ã£o de churn
cancelou = df['Churn'].sum()
total = df['Churn'].notnull().sum()
proporcao = cancelou / total * 100

print(f"Aproximadamente {proporcao:.2f}% dos clientes cancelaram o serviÃ§o.")

print(f"""
ğŸ¯ InterpretaÃ§Ã£o:

- Cerca de {proporcao:.2f}% dos clientes cancelaram seus serviÃ§os.
- Esse valor Ã© considerado **alto** no mercado, indicando que a empresa enfrenta um problema sÃ©rio de retenÃ§Ã£o.
- Clientes ativos (Churn = 0) representam a maioria, mas o volume de evasÃ£o Ã© relevante e merece investigaÃ§Ã£o.
""")

"""## ğŸ”  3.3 EvasÃ£o por VariÃ¡veis CategÃ³ricas

Aqui investigamos como a evasÃ£o varia de acordo com variÃ¡veis como `gender`, `contract`, `payment_method`, etc.

**Perguntas que queremos responder:**
- Certos perfis (ex: tipo de contrato ou mÃ©todo de pagamento) tÃªm maior probabilidade de churn?
- HÃ¡ diferenÃ§as de evasÃ£o entre gÃªneros ou faixas de serviÃ§o?

---
"""

# ğŸ“Š FunÃ§Ã£o para plotar a relaÃ§Ã£o entre churn e qualquer variÃ¡vel categÃ³rica
def plot_churn_by_category(col):
    plt.figure(figsize=(15, 6))
    sns.countplot(data=df, x=col, hue='Churn', palette='Set2')
    plt.title(f"EvasÃ£o por {col}")
    plt.xlabel(col.replace("_", " ").title())
    plt.ylabel("Quantidade de Clientes")
    plt.legend(title='Churn', labels=['Permaneceu (0)', 'Cancelou (1)'])
    plt.xticks(rotation=30)
    plt.grid(axis='y', linestyle='--', alpha=0.5)
    plt.tight_layout()
    plt.show()

plot_churn_by_category('payment_method')

plot_churn_by_category('contract')

# ğŸ’¡ ObservaÃ§Ã£o sobre churn por tipo de contrato
churn_by_contract = df.groupby('contract')['Churn'].mean().sort_values(ascending=False)

print(f"""
ğŸ“Š EvasÃ£o por Tipo de Contrato:

- Contrato com maior churn: {churn_by_contract.index[0].capitalize()} ({churn_by_contract.iloc[0]*100:.2f}% de cancelamento)
- Contrato com menor churn: {churn_by_contract.index[-1].capitalize()} ({churn_by_contract.iloc[-1]*100:.2f}% de cancelamento)

ğŸ§  Insight:
Clientes com contrato '{churn_by_contract.index[0]}' cancelam **muito mais** do que os que tÃªm contrato '{churn_by_contract.index[-1]}'.
Isso sugere que contratos mais longos (como 'two year') ajudam na **retenÃ§Ã£o**.
""")

plot_churn_by_category('payment_method')

plot_churn_by_category('internet_service')

plot_churn_by_category('tech_support')

plot_churn_by_category('online_security')

plot_churn_by_category('streaming_tv')

plot_churn_by_category('gender')

# ğŸ§  FunÃ§Ã£o para gerar insights textuais com f-string
def churn_insight_por_categoria(col):
    churn_por_categoria = df.groupby(col)['Churn'].mean().sort_values(ascending=False)

    print(f"""
ğŸ“Š EvasÃ£o por {col.replace('_', ' ').title()}:

- Categoria com maior churn: {churn_por_categoria.index[0].capitalize()} ({churn_por_categoria.iloc[0]*100:.2f}% de cancelamento)
- Categoria com menor churn: {churn_por_categoria.index[-1].capitalize()} ({churn_por_categoria.iloc[-1]*100:.2f}% de cancelamento)

ğŸ§  Insight:
Clientes da categoria '{churn_por_categoria.index[0]}' apresentam maior tendÃªncia ao cancelamento, enquanto aqueles da categoria '{churn_por_categoria.index[-1]}' sÃ£o mais propensos Ã  retenÃ§Ã£o.
""")

churn_insight_por_categoria('payment_method')

churn_insight_por_categoria('internet_service')

churn_insight_por_categoria('tech_support')

churn_insight_por_categoria('online_security')

churn_insight_por_categoria('streaming_tv')

"""## ğŸ”¢ 3.4 EvasÃ£o por VariÃ¡veis NumÃ©ricas

Vamos observar como a evasÃ£o se distribui em relaÃ§Ã£o a variÃ¡veis como `charges_total`, `charges_monthly`, `tenure`, e `daily_charges`.

**Perguntas que queremos responder:**
- Clientes com maior tempo de casa tendem a sair menos?
- Clientes com valores mais altos de conta estÃ£o mais propensos ao cancelamento?

---
"""

# ğŸ“Š FunÃ§Ã£o para comparar variÃ¡veis numÃ©ricas por churn
def plot_box_by_churn(numeric_col):
    plt.figure(figsize=(12, 6))
    sns.boxplot(data=df, x='Churn', y=numeric_col, palette='Set2')
    plt.title(f'{numeric_col.replace("_", " ").title()} vs Churn')
    plt.xlabel('Churn (0 = Permaneceu, 1 = Cancelou)')
    plt.ylabel(numeric_col.replace("_", " ").title())
    plt.grid(axis='y', linestyle='--', alpha=0.5)
    plt.tight_layout()
    plt.show()

plot_box_by_churn('tenure')

plot_box_by_churn('charges_monthly')

plot_box_by_churn('charges_total')

plot_box_by_churn('daily_charges')

# ğŸ§  Gera observaÃ§Ã£o automÃ¡tica para variÃ¡veis numÃ©ricas com base em churn
def churn_insight_por_variavel_numerica(col):
    media_cancelou = df[df['Churn'] == 1][col].mean()
    media_ficou = df[df['Churn'] == 0][col].mean()

    print(f"""
ğŸ“Š ComparaÃ§Ã£o de {col.replace('_', ' ').title()} entre grupos:

- MÃ©dia para clientes que **cancelaram**: {media_cancelou:.2f}
- MÃ©dia para clientes que **permaneceram**: {media_ficou:.2f}

ğŸ§  Insight:
Clientes que cancelaram tendem a ter valores de '{col.replace('_', ' ').lower()}' { 'menores' if media_cancelou < media_ficou else 'maiores' } do que os que permaneceram.
""")

churn_insight_por_variavel_numerica('tenure')

churn_insight_por_variavel_numerica('charges_total')

"""## ğŸ”— 3.5 (Extra) CorrelaÃ§Ã£o entre VariÃ¡veis

Como passo opcional, vamos explorar relaÃ§Ãµes lineares entre variÃ¡veis numÃ©ricas e o churn.

**Perguntas que queremos responder:**
- Existe correlaÃ§Ã£o entre `tenure` e `churn`?
- A quantidade de serviÃ§os contratados se relaciona com a evasÃ£o?

---
"""

# ğŸ”— Selecionar apenas colunas numÃ©ricas
df_num = df.select_dtypes(include=['int64', 'float64'])

# ğŸ“Š Matriz de correlaÃ§Ã£o
corr = df_num.corr()

# ğŸ”¥ Heatmap
plt.figure(figsize=(20, 15))
sns.heatmap(corr, annot=True, fmt=".2f", cmap="coolwarm", vmin=-1, vmax=1)
plt.title("ğŸ”— CorrelaÃ§Ã£o entre VariÃ¡veis NumÃ©ricas")
plt.tight_layout()
plt.show()

# ğŸ§  Interpretando as principais correlaÃ§Ãµes com Churn
corr_com_churn = corr['Churn'].drop('Churn').sort_values()

# Top 3 correlaÃ§Ãµes negativas
mais_negativas = corr_com_churn.head(3)
# Top 3 correlaÃ§Ãµes positivas
mais_positivas = corr_com_churn.tail(3)

print(f"""
ğŸ“Š Principais CorrelaÃ§Ãµes com Churn:

ğŸ”» CorrelaÃ§Ãµes Negativas (quanto maior o valor, menor a chance de churn):
- {mais_negativas.index[0]}: {mais_negativas.iloc[0]:.2f}
- {mais_negativas.index[1]}: {mais_negativas.iloc[1]:.2f}
- {mais_negativas.index[2]}: {mais_negativas.iloc[2]:.2f}

ğŸ”º CorrelaÃ§Ãµes Positivas (quanto maior o valor, maior a chance de churn):
- {mais_positivas.index[0]}: {mais_positivas.iloc[0]:.2f}
- {mais_positivas.index[1]}: {mais_positivas.iloc[1]:.2f}
- {mais_positivas.index[2]}: {mais_positivas.iloc[2]:.2f}

ğŸ§  Insight:
A variÃ¡vel com maior correlaÃ§Ã£o negativa com churn Ã© '{mais_negativas.index[0]}', sugerindo que quanto mais ela aumenta, menor Ã© a evasÃ£o. JÃ¡ '{mais_positivas.index[-1]}' apresenta correlaÃ§Ã£o positiva, indicando possÃ­vel relaÃ§Ã£o direta com cancelamento.
""")

"""# ğŸ§¾ RelatÃ³rio Final â€“ AnÃ¡lise de EvasÃ£o de Clientes (Churn)

## ğŸ¯ Objetivo

O projeto teve como objetivo analisar os dados da operadora fictÃ­cia **Telecom X** para entender os principais fatores relacionados Ã  evasÃ£o de clientes (churn). A partir de anÃ¡lises descritivas e exploratÃ³rias, buscou-se identificar perfis e padrÃµes de comportamento associados ao cancelamento dos serviÃ§os.

---

## ğŸ§¹ Limpeza e TransformaÃ§Ã£o dos Dados

- Os dados foram extraÃ­dos de um arquivo JSON e transformados de uma estrutura aninhada para um formato tabular.
- Foram tratadas inconsistÃªncias como valores ausentes em `Churn` e tipos incorretos em `charges_total`.
- As colunas foram padronizadas para `snake_case` e variÃ¡veis binÃ¡rias foram convertidas para `0` e `1`.

---

## ğŸ“Š Principais AnÃ¡lises e Insights

- **Churn** atinge cerca de **26,5% dos clientes**, Ã­ndice considerado **alto** para o setor.
- Clientes com **contrato mensal (month-to-month)** apresentaram o maior Ã­ndice de evasÃ£o (**42,7%**).
- Clientes com contratos de **dois anos** tiveram churn **inferior a 3%**, indicando forte relaÃ§Ã£o entre **tempo de fidelizaÃ§Ã£o** e retenÃ§Ã£o.
- VariÃ¡veis como `tenure` e `charges_total` mostraram correlaÃ§Ã£o negativa com churn, enquanto `charges_monthly` e `paperless_billing` mostraram correlaÃ§Ã£o positiva.
- Clientes com menor tempo de permanÃªncia e menor valor total gasto sÃ£o os que mais cancelam.

---

## âœ… RecomendaÃ§Ãµes EstratÃ©gicas

Com base nos padrÃµes identificados, sugerimos as seguintes aÃ§Ãµes para reduÃ§Ã£o do churn:

1. **Incentivar contratos de longo prazo** (ex: "dois anos") com benefÃ­cios exclusivos ou descontos progressivos.
2. **Criar campanhas de retenÃ§Ã£o para clientes novos**, principalmente nos primeiros 12 meses â€” perÃ­odo crÃ­tico de evasÃ£o.
3. **Monitorar clientes com contas mensais altas**, pois estÃ£o mais propensos a cancelar. Avaliar percepÃ§Ã£o de valor desses serviÃ§os.
4. **Avaliar o impacto da fatura digital**: usuÃ¡rios de `paperless_billing` tÃªm maior churn. Isso pode indicar um perfil mais impaciente, digital-first â€” ideal para testes A/B com experiÃªncias personalizadas.
5. **Explorar perfis familiares com dependentes** como segmento estratÃ©gico â€” tendem a ser mais fiÃ©is.

---

## ğŸ§  ConclusÃ£o

A anÃ¡lise permitiu identificar padrÃµes claros de comportamento associados Ã  evasÃ£o. O entendimento desses fatores Ã© essencial para o desenvolvimento de estratÃ©gias mais direcionadas de retenÃ§Ã£o, que poderÃ£o ser aprofundadas com modelos preditivos em uma prÃ³xima etapa.
"""